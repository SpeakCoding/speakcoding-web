import React from 'react';
import { HL, Pre, Section } from '@sc/ui';

export default () => (
    <Section>
        <Section.Main hlactive narrow>
            <h2>Функции добавления и чтения записей в базах данных</h2>
            <p>
                Внутри наследуемого класса <b>ActiveRecord</b> будут храниться статические функции,
                которые позволяют непосредственно читать и изменять данные из таблиц в базе данных.
            </p>
            <p>
                Представим, что мы хотим создать новый пост. Вот как будет выглядеть эта функция на
                стороне сервера.
            </p>
            <Pre>
                @post = <HL color='light-sky-blue'>Post.new</HL>(<HL color='green'>post_params</HL>){' '}
                <br />
                @post.user = current_user <br />@<HL color='light-sky-blue'>post.save</HL>
            </Pre>
            <p>
                Здесь сервер получит <HL color='green'>набор параметров поста</HL> (данные, которые
                пользователь ввел в форму на клиенте) и, вызвав автоматическую функцию <b>create</b>{' '}
                класса ActiveRecord, создаст экземпляр поста и сохранит его в свою базу данных.
                Фактически класс ActiveRecord позволяет нам не писать SQL запрос INSERT (добавления
                строки в базу данных), а произвести операцию автоматически, через наследуемые
                функции класса.
            </p>
            <p>
                <b>Еще один пример:</b>
            </p>
            <Pre>
                @post = Post.<HL color='red'>find</HL>(params[<HL color='light-sky-blue'>:id</HL>])
            </Pre>
            <p>
                Здесь сервер получил от клиента параметры, в частности,{' '}
                <HL color='light-sky-blue'>id</HL> и, с помощью функции <HL color='red'>find</HL>{' '}
                (унаследована вместе с ActiveRecord) он сделает запрос SELECT и найдет в таблице
                Post все посты с таким user id.
            </p>
            <p>
                Если мы изменяем конкретный пост, то статическая функция <b>update</b> класса
                ActiveRecord произведет SQL запрос UPDATE в базу данных и заменит значения на{' '}
                <HL color='orange' inline={3}>
                    полученные от клиента параметры
                </HL>
                :
            </p>
            <Pre>
                @post = current_user.posts.find(params[:id]) <br />
                @post.attributes = <HL color='orange'>post_params</HL> <br />@
                <HL color='light-sky-blue'>post.save</HL>
            </Pre>
            <p>
                <b>Резюмируя отличия описания model классов на сервере, можно отметить, что:</b>
            </p>
            <ul>
                <li>
                    класс на сервере создается на основании описания составляющих, указанных в БД
                    (например, у Like появится “составляющая” post_id).
                </li>
                <li>
                    мы также описываем класс через то, с какими другими сущностями программы он
                    связан. То есть, в отличие от описания структурного класса на клиенте, на
                    сервере мы описываем связи между таблицами (как пользователи связаны с постами).
                </li>
                <li>
                    эти связи нужны, чтобы в коде мы могли в одной строке написать команды,
                    обращаясь к функциям и составляющим классов в обход SQL запросов, как в примере
                    ниже:
                </li>
            </ul>
            <Pre>@posts = Post.preload(:comments).where(user: users).order('created_at desc')</Pre>
        </Section.Main>
    </Section>
);
