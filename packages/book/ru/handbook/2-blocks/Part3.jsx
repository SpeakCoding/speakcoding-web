import React from 'react';
import { Pre } from '@sc/ui';
import { format } from './utils';
import s from './style.css';

export default () => (
    <>
        <p>
            <b>Функция инициализации класса и создание экземпляра класса</b>
        </p>
        <Pre>
            {format`
            class ИмяКласса {
                func init(имяВводной: КлассВводной, ...) {

                } 
            }`}
        </Pre>
        <p>В языке Swift функция инициализации называется init.</p>
        <Pre>ИмяКласса(имяВводной: ЗначениеВводной, ...)</Pre>
        <p>
            Для создания экземпляра класса мы используем имя класса (помним, что оно начинается с
            большой буквы) и после скобок перечисляем вводные (как и в случае вызова функций). В
            отличие от определения класса, в init нет ключевого слова class и есть перечисление
            вводных.
        </p>
        <Pre>... = ИмяКласса(имяВводной: ЗначениеВводной, ...)</Pre>
        <p>
            Создание экземпляров вы будете встречать по правую сторону знака равенства, так как мы
            хотим сохранить их в переменной или как составляющую экземпляра какого-то класса
        </p>
        <Pre>{`{{имяФункции}}(t:func)(имяВводнойФункции: ИмяКласса(...))`}</Pre>
        <p>или при указании значения одной из составляющих функции.</p>
        <div className={s.gap} />

        <p>
            <b>Шаги функции</b>
        </p>
        <p>Каждая отдельная строка - отдельный шаг.</p>
        <Pre>
            {format`
            self.имяСоставляющей

            self.имяФункции()`}
        </Pre>
        <p>
            ункции класса будут выполняться для конкретных экземпляров этого класса (за исключением
            static). Для обращения к составляющим или функциям конкретного экземпляра мы можем
            писать их имена, или, для лучшей читаемости, использовать ключевое слово self, после
            точка, затем имя составляющей/функции этого класса.
        </p>
        <Pre>... = self</Pre>
        <p>
            При этом само упоминание self без точки после означает сам экземпляр класса, для
            которого вызывается функция.
        </p>
        <Pre>
            {format`
            func имяФункции(имяВводной: КлассВводной) {
                ... = имяВводной
            }`}
        </Pre>
        <p>К вводным функции обращаются по их именам.</p>
        <Pre>var имяПеременной</Pre>
        <p>
            Вы узнаете переменные по ключевым словам var или let, после которых следует имя
            переменной (начинается с маленькой буквы, каждое последующее слово в названии с большой
            буквы).
        </p>
        <Pre>var имяПеременной = ...</Pre>
        <p>В этой же строке после знака равенства может быть указано значение переменной.</p>
        <Pre>self.имяСоставляющей = ...</Pre>
        <p>
            Для того, чтобы изменять значение составляющей или переменной, мы пишем ее имя, после
            чего знак равенства и ее новое значение.
        </p>
        <p>
            Если при указании значения мы используем [ ] скобки, значит мы создаем набор некоторого
            класса, внутри этих [ ] скобок мы перечисляем элементы этого создаваемого набора.
        </p>
        <Pre>
            {format`
            self.имяСоставляющей.имяСубСоставляющей

            self.имяСоставляющей.имяСубФункции ()`}
        </Pre>
        <p>
            Если после составляющей/переменной (и то, и другое - экземпляр некоторого класса) идет .
            точка, после которой имя составляющей или функции, значит, мы таким образом обращаемся к
            их “суб”-составляющим ( чтобы получить их содержимое или чтобы изменить).
        </p>
        <Pre>self.имяФункции().имяСубСоставляющей</Pre>
        <p>
            Если функция возвращает некоторое значение, то можно сразу обращаться к
            “суб”-составляющим класса возвращаемого значения.
        </p>
        <Pre>{`{{имяФункции}}(t:func)(имяВводной: self.имяФункции().имяСубСоставляющей)`}</Pre>
        <p>
            Из главы про сложноподчиненные предложения вы знаете, что такая последовательность может
            быть продолжительной.
        </p>
        <p>
            Такая последовательность может быть так задана как вводная для функции, при условии, что
            эта последовательность выдает значение того же класса, что класс вводной этой функции.
        </p>
        <Pre>self.имяСоставляющей?.имяСубСоставляющей</Pre>
        <p>
            Внутри такой последовательности вы можете встретить вопросительный и восклицательный
            знаки. Если мы хотим обратиться к “суб”-составляющей или “суб”-функции, некоторой
            составляющей, которая может быть пустой, то мы должны поставить ? (чтобы компилятор
            вставил сначала дополнительную проверку, что составляющая не пустая). Если же мы
            уверены, что на данном этапе исполнения программы она точно должна быть задана, мы можем
            поставить ! восклицательный знак.
        </p>
        <Pre>
            {format`
            let имяПеременной = 1

            self.имяФункции(имяВводной: 1.5)

            self.имяПеременной = "Text Should be here"`}
        </Pre>
        <p>
            Значение переменной может быть цифрой, тогда в коде будет просто написана цифра. Если
            значение - текстовая строка, она будет задана в скобках " ".
        </p>
        <Pre>"You have \(self.comments.count()) comments"</Pre>
        <p>
            Внутрь статичной строки можно добавить изменяющуюся часть. Для этого внутри " " кавычек,
            в месте где мы хотим вставить изменяющееся значение, мы пишем \ знак обратной дроби и
            (скобку, после чего вставляем необходимое значение и закрываем ) скобкой.
        </p>
        <Pre>
            {format`
            var имяПеременной = false

            self.имяФункции(имяВводной: nil)`}
        </Pre>
        <p>
            Значение переменной также может быть true/false (класса Bool). Или nil - пустое
            значение. <b>bool</b> означает, что в результате выполнения этого шага мы должны
            получить ответ да/нет (1 или 0, верно/не верно).
        </p>
        <Pre>var имяПеременной = ИмяКласса.имяСтатичискойСоставляющей</Pre>
        <p>
            Если мы видим имя класса после которого сразу идет точка и имя составляющей или функции,
            значит, мы обращаемся к статической составляющей или функции. Так как они общие для всех
            экземпляров класса, можно обращаться не к экземпляру, а просто к классу.
        </p>
        <Pre>var имяПеременной = ИмяКласса.ИмяEnum.имяЕлементаEnum</Pre>
        <p>
            Также внутри класса может быть определен <b>enum</b>. Enum - используется, когда в
            числовом значении хранятся какие-то осмысленные перечисления (например, цвета радуги
            вместо названий цвета хранятся цифрами). В коде вы сможете видеть присвоенные этим
            числам значения, но компилятор прочтет их как цифры. В случае использования enum, после
            имени класса через точку мы обратимся к имени enum и, еще через точку, к одному из его
            элементов.
        </p>
        <div className={s.gap} />
    </>
);
