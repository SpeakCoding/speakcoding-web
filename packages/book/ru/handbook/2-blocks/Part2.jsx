import React from 'react';
import { Pre } from '@sc/ui';
import { format } from './utils';
import s from './style.css';

export default () => (
    <>
        <p>
            <b>Описание функций</b>
        </p>
        <Pre>
            {format`
            func имяФункции(вводная, другаяВводная) -> КлассВозвращЗначения {
            
            }`}
        </Pre>
        <p>
            В общем виде это ключевое слово func после которого идет имя функции (начинается с
            маленькой буквы, каждое последующее слово в названии с большой буквы), после которого в
            ( ) скобках через запятую перечисляются вводные. После чего -> и класс возвращаемого
            значения. Далее в {'{ }'} описание шагов функции.
        </p>
        <Pre>
            {format`
            func имяФункции () -> КлассВозвращЗначения {

            }`}
        </Pre>
        <p>TЕсли вводных не требуется, в скобках пусто.</p>
        <Pre>
            {format`
            func имяФункции (вводная, другаяВводная) {

            }`}
        </Pre>
        <p>
            Если функция не возвращает никакого значения, то -> и класс возвращаемого значения не
            пишется.
        </p>
        <Pre>
            {format`
            func имяФункции (имяВводной: КлассВводной, имяДругойВводной: КлассДругойВводной) {

            }`}
        </Pre>
        <p>
            Для каждой вводной задается имя (начинается с маленькой буквы, каждое последующее слово
            в названии с большой буквы), после которого идет двоеточее и имя класса этой вводной.
        </p>
        <p>
            Перед ключевым словом func, могут быть записаны дополнительные ключевые слова (через
            пробел).
        </p>
        <Pre>
            {format`
            override func имяФункции() {
                super.имяФункции()
                ...
            }`}
        </Pre>
        <p>
            <b>override</b> - ключевое слово показывающее, что, хотя данная функция уже существует в
            "родительском" классе, в нашем классе она переписана, т.е. выглядит и работает иначе.
            При чтении кода компилятор будет сравнивать не только имя функции, но и состав вводных.
            Т.е. функция с новым набором вводных будет восприниматься как новая функция, а не как
            функция, заменяющая материнскую.
        </p>
        <p>
            Если мы хотим добавить дополнительные шаги к выполнению функции, оставив изначальные
            действия, то в дочерней функции мы пишем строку с ключевым словом <b>super</b> (иногда
            вместе с именем функции через точку). Оно вызовет все действия, описанные в функции
            материнского класса.
        </p>
        <Pre>
            {format`
            required func имяФункции() {

            }`}
        </Pre>
        <p>
            <b>required</b> означает, что наследуемую функцию, упомянутую в классе, от которого мы
            ее наследуем, нужно обязательно определить в текущем (наследующем) классе.
        </p>
        <p>
            <b>public/private</b> - по аналогии с составляющими, private означает, что эту функцию
            можно читать/изменять только внутри этого класса. Противоположность private - это или
            отсутствие ключевых слов перед функцией или слово public.
        </p>
        <p>
            <b>@IBAction</b> - означает, что в этой функции определены события и соответствующие им
            действия, связанные с каким-то стандартным элементом интерфейса, описанного в .xib
            файле.
        </p>
        <div className={s.gap} />

        <p>
            <b>Вызов функции</b>
        </p>
        <Pre>имяФункции(имяВводной: значаниеДляВводной)</Pre>
        <p>
            Вызов функции осуществляется за счет написания имени функции без ключевого слова перед
            ним, после которого в ( ) скобках через запятую перечисляются значения (экземпляры
            необходимых классов) для этих вводных (само значение или переменная содержащие это
            значение). В языке swift при вызове функции каждой вводной нужно написать не только
            значение, которое мы передаем, но и ее имя.
        </p>
        <Pre>
            {format`
            func имяФункции(допИмяВводной имяВводной: КлассВводной){

            }

            имяФункции(допИмяВводной: значаниеДляВводной)`}
        </Pre>
        <p>
            По умолчанию, вводные имеют такое же название, как вы указали при описании функции.
            Однако в языке swift каждой переменной может быть задано дополнительное имя. В таком
            случае именно это дополнительное имя будет использоваться при вызове функций, когда
            перечисляются вводные. Это имя пишется перед основным именем переменной, через пробел.
        </p>
        <Pre>
            {format`
            func имяФункции(_ имяВводной: КлассВводной){

            }

            имяФункции(значаниеДляВводной)`}
        </Pre>
        <p>
            Вместо дополнительного имени может быть написан _ прочерк. В таком случае при вызове
            функции для этой вводной не нужно писать ее имя.
        </p>
        <div className={s.gap} />
    </>
);
